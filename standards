This document describes guidelines for code which is to be
incorporated into the Athena source tree.  Here are the areas covered:

	Coding conventions
	Software engineering practices
	Portability considerations for code we maintain
	Portability considerations for code we release
	Portability considerations for code we get from third parties

Coding conventions
------------------

If you are working on an existing module which does not follow these
conventions, be consistent with the existent source code rather than
these conventions.

You should follow the section on "Writing C" in the Gnu coding
standards (available in emacs info under "standards"), with the
following changes:

	* When making a function call, do not put a space before the
	  open parenthesis.  Do put spaces before the open parenthesis
	  after "while", "if", or "for", though.

	* When defining a function, do not drop to the next line for
	  the name of the function; put the function name on the same
	  line as the return type.

	* Don't insert formfeed characters into source files to divide
	  programs into pages.

	* Ignore the sections on "Portability between System Types"
	  and "Portability between CPUs"; see the sections on
	  portability in this file instead.  Also ignore the section
	  on "Internationalization."

	* In the section "Calling System Functions," ignore everything
	  about string functions.  These days you can assume that
	  using "#include <string.h>", strchr(), and strrchr() will
	  work on just about all platforms.

You can use "M-x set-c-style" "GNU" in emacs to have emacs take care
of the gnu-style indentation for you.  Remember to drop to the next
line before each open brace.

When writing return statements, do not put parentheses around the
return value; just write "return foo;".  This convention is not
specified in the Gnu coding standards, but is consistent with the
examples in the standards.

Each C source file should begin with an MIT copyright statement, a
comment describing what the file does, and a line:

	static char rcsid[] = "$Id: $";

Each C header file should begin with:

	/* $Id: $ */

followed by an MIT copyright statement and a comment describing what
the file does.

The preferred convention for comments is

	/* comment text */

for one line comments, and

	/* comment text line 1
	 * comment text line 2
	 */

for multi-line comments.  As recommended in the Gnu coding standards,
your comments should normally be complete, capitalized sentences
ending with a period.

Software engineering practices
------------------------------

The following software engineering practices are strongly encouraged:

	* Restricting the operations which can access a given type of
	  data object, and grouping them together.  (This is called
	  "encapsulation" and is considered one of the important
	  aspects of "object-oriented programming.")

	* Documenting data invariants (i.e. conditions on the
	  representations of data objects which are assumed to always
	  be true) and the meaning of data representations.

	* Documenting non-obvious requirements and effects of
	  procedures.

	* Use of prototypes for all functions.

	* Automated testing of both program components ("unit
	  testing") and whole programs ("integration testing").

The following software engineering practices are discouraged:

	* Use of global variables.  Remember that the complexity of
	  any function's interface is increased by the global
	  variables it uses, even if that doesn't show up in the
	  function prototype.  Global variables are marginally
	  acceptable to represent configuration parameters determined
	  by command-line arguments or a configuration file, but even
	  then it is preferrable to find an alternative.

	* Use of global process state.  You should avoid using
	  alarm(), and you should avoid using getuid() or getenv()
	  inside libraries or other "deep" interfaces.  Code that uses
	  global process state tends to interact poorly with other
	  code in large programs.

Portability considerations for code we maintain
-----------------------------------------------

In general, your code should assume a POSIX-compliant and ANSI
C-compliant development environment.

Sometimes our platforms may have bugs in POSIX interfaces but not in
BSD interfaces (e.g. under Ultrix 4.2, setpgid() works but setsid()
does not).  See the file "lossage" in this directory for descriptions
of particular bugs and incompatibilities and how to handle them.

Some important operations (especially in code in the Athena
environment) are not covered by the ANSI C or POSIX specifications.
See the file "nonstd" in this directory for descriptions of how to
handle some of them.

In general, you should use Autoconf to handle portability concerns;
see the file "build-system" in this directory for how a file in the
athena hierarchy should use autoconf.  If you must perform an
operating system test (because the source tree you're working on
doesn't use Autoconf and you don't have the time to make it do so), do
it in two steps; for instance:

	#define HAVE_STRERROR
	#if defined(sun) && !defined(__svr4__)
	/* SunOS 4.1.3_U1 doesn't have strerror().  Use sys_errlist
	 * instead. */
	#undef HAVE_STRERROR
	#endif

	#ifndef HAVE_STRERROR
	extern const char *const sys_errlist[];
	#define strerror(x) (sys_errlist[x])
	#endif

This way, if the source tree is ever converted to use feature tests,
the person porting the code will know exactly what needs to be tested
for.  If you can anticipate the preprocessor symbol which would be
used with Autoconf (as in this example), that's even better.  Note
particularly the comment instead the operating system test; it should
specify:

	* What special consideration is needed for that operating
	  system.

	* The version number of the operating system for which this
	  approach was determined to be necessary.

This will help future maintainers determine if one can eliminate the
special consideration altogether when an OS upgrade has happened.

Following is a list of appropriate preprocessor symbols to use to
detect platforms we care about:

	Solaris:	#ifdef SOLARIS
	IRIX		#ifdef sgi
	Linux:		#ifdef linux
	NetBSD:		#ifdef __NetBSD__
			or #include <sys/param.h> and #ifdef BSD4_4
			if applicable to all BSD 4.4 systems.

SOLARIS is not automatically defined by the compiler on Solaris
systems; we make sure it's defined when we build our code.  There are
no reliable automatically defined constants for Solaris systems.

Portability considerations for code we release
----------------------------------------------

All of the standards in the previous section apply; however, we
generally care about more platforms for code we release to the outside
works.  It is discouraged, but acceptable, to care about platforms
which are not POSIX-compliant.  Code that cares about such platforms
should determine whether the platform supports POSIX interfaces by
using AC_CHECK_HEADERS(unistd.h) to determine whether it can #include
<unistd.h>, and then checking whether _POSIX_VERSION is defined.

Portability considerations for code we get from third parties
-------------------------------------------------------------

The overriding principle for code obtained from third parties is to
make as few changes as possible.  A lot of third-party code has a very
bad approach to portability, or cares about a lot of platforms we
don't care about.  You should attempt to follow the portability
approach used by the rest of the program, such as it may be.  Ideally,
any changes you make should be made in such a manner that they can be
incorporated into the source tree maintained by the third party.
