This file contains notes about the care and feeding of the Athena
source repository.  It is intended primarily for the administrators of
the source tree, not for developers (except perhaps for the first
section, "mailing lists").  See the file "procedures" in this
directory for information about procedures relevant to developers.

The areas covered in this file are:

	Mailing lists
	Permissions
	The wash process
	Building the tree
	Imake templates
	Release cycles

Mailing lists
-------------

Here are descriptions of the mailing lists related to the source tree:

	* source-developers

		For discussion of the policy and day-to-day
		maintenance of the repository.  To be a member of this
		mailing list, you must be a staff member, but there is
		a public discuss archive on menelaus.

	* source-reviewers

		For review of changes to be checked into the
		repository.  To be a member of this mailing list, you
		must have read access to the non-public parts of the
		source tree, but you do not need to be a staff member.
		There is a non-public discuss archive on menelaus.

	* source-commits

		This mailing lists receives commit logs for all
		commits to the repository.  This is a public mailing
		list.  There is a public discuss archive on menelaus.

	* source-diffs

		This mailing list receives commit logs with diffs for
		all commits to the repository.  To be on this mailing
		list, you must have read access to the non-public
		parts of the source tree.  There is no discuss archive
		for this list.

	* source-wash

		This mailing list receives mail when the wash process
		blows out.  This is a public mailing list.  There is
		no discuss archive for this list.

	* rel-eng

		The release engineering mailing list.  Mail goes here
		about patch releases and other release details.  There
		is a public archive on menelaus.

	* release-team

		The mailing list for the release team, which sets
		policy for releases.  There is a public archive on
		menelaus (currently, it has the name "release-77").

Permissions
-----------

Following are descriptions of the various groups found on the acls of
the source tree:

	* read:source
	  read:staff

		These two groups have identical permissions in the
		repository, but read:source contains artificial
		constructs (the builder user and service principals)
		while read:staff contains people.  In the future,
		highly restricted source could have access for
		read:source and not read:staff.

		Both of these groups have read access to non-public
		areas of the source tree.

	* write:staff

		Contains developers with commit access to the source
		tree.  This group has write access to the repository,
		but not to the checked-out copy of the mainline
		(/source).

	* write:update

		Contains the service principal responsible for
		updating /source.  This group has write access to
		/source but not to the repository.

	* adm:source

		This group has administrative access to the repository
		and to /source.

system:anyuser has read access to public areas of the source tree and
list access to the rest.  system:authuser occasionally has read access
to areas that system:anyuser does not (synctree is the only current
example).

The script CVSROOT/afs-protections.sh in the repository makes sure the
permissions are correct in the repository or in a working directory.
Run it from the top level of the repository or of /source, giving it
the argument "repository" or "wd".

The wash process
----------------

The wash process is a nightly rebuild of the source repository from
scratch, intended to alert the source tree maintainers when someone
checks in a change which causes the source tree to stop building.  The
general architecture of the wash process is:

	* Each night at midnight, a machine (currently small-gods)
	  performs a cvs update of the checked-out tree in
	  /afs/dev.mit.edu/source/src-current.  If the cvs update
	  fails, the update script sends mail to source-wash@mit.edu.
	  This machine is on read:source and write:update.

	* Each night at 4:30am, a machine of each architecture
	  (currently snuggle and kenmore) recreates empty /build and
	  /localsrvd filesystems and performs a build of the tree with
	  /srvd pointed at /localsrvd.  If the build fails, the update
	  script sends mail to source-wash@mit.edu with the last few
	  lines of the wash log, and saves the wash log in /var/wash
	  on the local disk.

Source for the wash scripts lives in /afs/dev.mit.edu/service/wash.
They are installed in /usr/local on the wash machines, along with a
copy of krbtgp from the net-tools locker in /usr/local/bin.  Logs of
the start and end times of the wash processes on each machine live in
/afs/dev.mit.edu/service/wash/status/`hostname`.

Building the tree
-----------------

To build the tree by hand, you run the script
/source/packs/build/build.sh.  Building the tree has the following
requirements right now:

	* Either /source must point to the source directory, or you
	  must tell build.sh where to find the source tree using the
	  -s option.

	* You must have a link farm of the source tree generated by
	  synctree.  The default location is /build; you can specify
	  an alternative location with the -b option.

	* You must have write access to a destination tree, and be
	  able to chown file and make setuid root files in that tree.
	  The default location is /srvd; you can specify an
	  alternative location with the -d option.

	* /usr/athena and /usr/afsws need to point into the
	  destination tree, unless you don't mind using the old
	  include files and libraries (which may not work from release
	  to release).  On Solaris, /usr/gcc also needs to point into
	  the destination tree unless you don't mind using the old
	  compiler.

	* On Solaris, you need system:authuser access to the Athena
	  cell in order to build third/gcc (since it is bootstrapped
	  with the sunsoft compiler).

Imake templates
---------------

We don't like imake, but we maintain two sets of imake templates:

	* packs/build/config

		These templates are the legacy Athena build system.
		They are specific to software in the athena hierarchy,
		and one glorious day in the future they will no longer
		be necessary.

		For these templates, you should define TOPDIR to the
		top-level source directory.

	* packs/build/xconfig

		These templates are used for building software which
		uses X-style Imakefiles.  They may need periodic
		updating as new versions of X are released.  These
		templates are full of a lot of hacks, mostly because
		the imake model isn't really adequate for dealing with
		third-party software and local site customizations.

		For these templates, you should define TOPDIR to "."
		and SRCDIR to the top-level source directory.

Release cycles
--------------

We haven't had one yet with the current repository, but some notes on
how they should be carried out:

	* doc/third-party should be checked to see if any tidbits of
	  third-party material need to be updated before a release
	  cycle.

	* A branch should be made for each release cycle, of the form
	  "athena-8_1".  Only the release engineers should commit on
	  release branches.

	* A tag should be made on the release branch for each patch
	  release, of the form "athena-8_1_0".

	* A checked-out tree should be made in /afs/dev.mit.edu/source
	  for each release cycle, following the branch for that cycle.

	* System packs should be created in a directory of the form
	  "/afs/dev.mit.edu/system/${ATHENA_SYS}/srvd-8_1".

	* A build machine should be set up for each platform, with a
	  local build tree and an /srvd pointing to the read-write
	  volume.

	* The release cycle should begin with a full build of the
	  source; individual packages should be rebuilt with the build
	  script (moving any relevant binaries into .deleted first),
	  followed by a rebuild of packs/build/finish.
